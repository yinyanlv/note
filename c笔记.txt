编译过程
预处理  // 得到.i文件，将所有#include的头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多
编译  // 得到.s文件，将经过预处理之后的程序转换成特定汇编代码
汇编  // 得到.o文件，将汇编代码转换成机器码
链接  // 将多个目标文件以及所需的库文件(.so等)链接生成最终的可执行文件

gcc  // GNU Compiler Collection
gcc -E hello.c > hello.i  // 输出预处理文件
gcc -S hello.c > hello.s  // 输出汇编文件
gcc hello.c -o hello.out -L/usr/lib -lm  // -l，添加链接库，m是数学库libm.a的基本名称，-L，为gcc增加一个搜索链接库的目录
gcc -c hello.c  // 输出目标文件（.o/.obj），hello.o，编译器编译源代码但不执行链接
gcc -o hello.c hello  // 输出可执行文件hello，如果没有-o和后面的参数，gcc编译器默认输出a.out

静态链接库  // 在链接阶段，会将汇编生成的目标文件（.o/.obj）与引用到的库一起链接打包到可执行文件中
后缀名：
linux  .a  
windows  .lib
优点：
移植方便，程序在运行时与函数库再无关联
缺点：
浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成到一个可执行文件文件中，
不方便更新迭代，不能增量更新
linux创建静态库：
ar -crv libhello.a hello.o  // 需通过（ar/lib.exe）工具将目标文件打包成.a静态库文件

动态链接库  // 动态库在程序编译时并不会被链接到目标代码中，而是在程序运行是才被载入，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，动态库也称为共享库
后缀名:
linux .so 
windows .dll
优点：
节约空间和资源
方便更新迭代，可增量更新
缺点：
不方便移植
linux创建动态库：  // 不需要打包工具（ar/lib.exe），直接使用编译器即可创建动态库
gcc -fPIC -c hello.c  // 先生成目标文件，-fPIC，创建与地址无关的编译程序（pic，position independent code），为了能够在多个应用程序间共享
gcc -shared -o libhello.so hello.o  // 生成动态库，-shared，指定生成动态链接库
linux使用动态库：
gcc test.c -L../DynamicLibrary -lhello  // 引用动态库编译生成可执行文件的方法跟静态库一样，代码中需引用库的头文件。注意，linux动态库默认存放位置为/lib、/usr/lib，如果某动态库不在系统默认目录中，需要在系统中注册该动态库（ldconfig），否则编译器会找不到该动态库

进程是操作系统资源分配的最小单元。操作系统分配给进程的内存空间中包含五种段：
数据段  // 存放程序中的静态变量和已初始化且不为零的全局变量
代码段  // 存放可执行文件的操作指令，代码段是只读的，不可进行写操作。这部分的区域在运行前已知其大小
bss  // block started by symbol，存放未初始化的全局变量，在变量使用前由运行时初始化为零
堆  // 存放进程运行中被动态分配的内存，其大小不固定
栈  // 存放程序中的临时的局部变量和函数的参数值

逻辑地址  // 与当前数据在内存中的物理分配地址无关的访问地址，在执行对内存的访问之前必须转化为物理地址
物理地址  // 数据在内存中的实际位置

主要内存管理手段
分页
分段

‘\0’ -> 0
' ' -> 32
'0' -> 48
'a' -> 97
'A' -> 65

#define指令行的末尾不可以有分号
c语言不可以在函数内部再定义函数

默认情况下，外部变量和静态变量被初始化为0，未经显式初始化的自动变量的值为未定义值（即无效值）

static声明的外部变量和函数，它们的作用域限定为被编译源文件的剩余部分，之前的部分，即使使用extern也无法访问
static声明的局部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量

const static == statci const
const限定符指定变量的值不能被修改，它本身是类型系统的一部分，类型匹配时需带上
const int *ptr = &x;  // 常量指针，ptr本身可变，但指向的内容不可变
int * const ptr = &x;  // 常量指针变量（变量的常量指针），ptr本身不可变，但指向的内容可变
const int * const ptr = &x;  // 指针常量（常量的常量指针），ptr本身不可变，指向的内容也不可变

register声明寄存器变量，只适用于自动变量以及函数的形式参数

根据定义，数组类型的变量或表达式的值是该数组第0个元素的地址，即arr实质上是&arr[0]
ptr = arr 等价于 ptr = &arr[0]  // ptr，指针变量名，一般情况下，用指针编写的程序比用数组下标编写的程序执行速度快。在计算数组元素arr[i]的值时，c语言实际上先将其转换为*(arr+i)的形式，然后再进行求值
&arr[i] 等价于 ptr + i
arr[i] 等价于 *(ptr + i)
数组名和指针之间有一个不同之处。指针是一个变量，因此，ptr = arr，ptr++都是合法的，但数组名不是变量，因此，arr = ptr，arr++都是非法的，但是arr + 1是合法的，因为并没有赋值
在函数定义中，形式参数char *arr等价于char arr[]，推荐使用前者，因为它更直观的表明该参数实质上是一个指针

*p++  // 先取值，后指针++
*++p  // 先指针++，后取值
++*p  // 先取值，后值++
(*p)++  // 先取值，后值++

数组指针  // int (*p)[10]，指向数组的指针，主要用于指向二维数组的某一行
int a[10];
int (*p)[10] = &a;  // 注意，不可以int (*p)[10] = a;，因为，类型不匹配，a本质上是&a[0]，而p的类型是一个指向一维数组的指针（实际上是二级指针），该数组一定且只包含十个整型
int *p = a;  // 正确，p存放的a数组第一个元素的地址
int b[2][2] = {{1, 2}, {3, 4}};  // b是一个二维数组
int (*p1)[2] = b;  // 正确，p1存放的b数组第一个元素（{1, 2}而不是1）的地址，即数组指针，指向二维数组的第一行
指针数组  // int *p[10]，元素是指针的数组，一般情况下指针会指向动态分配的内存区域

一级指针（指向普通变量），二级指针（指向一级指针），三级指针（指向二级指针），多级指针。多级指针常与多维数组一起使用

通过指针可创建动态数组

指针，一种存放变量地址的变量，通常占用2或4个字节
c语言中，默认都是值传递，复制并新建内存，想共享内存只能通过指针
ANSI C使用类型void*代替char*作为通用指针的类型
对指针有意义的初始化值只能是0或者是表示地址的表达式，c语言保证，0永远不是有效的数据地址，因此，当指针的值为0时表示发生了异常事件
指针与整数类型之间不能相互转换，0是唯一的例外，常量0可以赋值给指针，指针也可以和常量0比较
程序中经常使用符号常量NULL代替0，NULL定义在标准头文件<stddef.h>中
在某些情况下，可以对指针进行比较运算，例如，对指向同一数组的两个指针进行比较，c语言对指向不同数组的两个指针之间的算术或比较运算没有定义
所有的指针运算都会自动考虑它所指向对象的长度，根据指向对象的长度按比例缩放

void类型，未确定类型或任何类型，表示“没有值可以获得”

空指针，NULL，值为0，不指向任何空间，所以不能使用间接运算符*取值
野指针，wild pointer，没有被初始化过的指针
悬空指针，dangling pointer，指针最初指向的内存已经被释放了的一种指针
void指针，指向void的指针，万能指针，表示未确定类型的指针，void指针指向一块内存，却没有告诉程序该如何解释这块内存，因此，不能直接用该类型的指针获取所指向内存的内容，必须先转换成具体类型的指针才行

sizeof 对象名  // 也可以sizeof(对象名)，返回占用存储空间字节数，类型size_t，该类型在头文件<stddef.h>中定义，实质上是无符号整型数
sizeof(类型名)

c语言堆内存操作接口
void *malloc(size_t size);  // 申请size个字节的堆内存，将首地址返回，失败返回NULL
void *calloc(size_t nmemb, size_t size);  // 申请nmemb个单元，每个单元size个字节
void *realloc(void *ptr, size_t size);  // 改变原来申请的空间的大小，将首地址返回
void free(void *ptr);  // 释放堆内存

c99标准
int main(void) {}
int main(int argc, char *argv[]) {}  // argc（argument count），命令行参数的个数，argv（argument vector），一个字符串数组，也可以写为char **argv

结构体  // 内存对齐，一般情况下，结构体类型变量的内存空间大小为结构体成员中（不包括派生类型，如数组、结构体、联合等）所占空间字节数最大值的整数倍。处理器一般不是按字节来存取内存，而是以2字节、4字节、8字节甚至32字节为单位来存取内存
struct coord {
    int x;
    int y;
};
定义时初始化
struct coord abc = {1,2};
struct coord abc = {.x=1, .y=2};  // c99，c11新增标准

ptr->a 等价于 (*ptr).a  // 括号不可以省略
entity.a 等价于 (&entity)->a  // 括号不可以省略

联合  // 又称共用体，一般编程中用的较少，在单片机中用的较多

位字段  // 结构体、联合的成员可以是位字段，单位bit，位字段是一个由具有特定数量位组成的整型变量，如果连续声明多个小的位字段，编译器会将它们合并为一个机器字
与结构中的其它成员不同，位字段通常不会占据可寻址的的内存位置（因为分配地址的基本单位是字节），因此无法对位字段采用地址运算符&，也不能对位字段进行位运算

文件
从用户角度，分为普通文件和设备文件（指与主机相连的各种外部设备，如显示器、键盘等，在操作系统中，把外部设备看作一个文件来管理。如显示器定义为标准输出文件，键盘定义为标准输入文件）
从文件的编码方式上，分为文本文件和二进制文件

标准输入输出函数
scanf
printf
getchar
putchar
gets
puts

文件指针  // FILE *file;FILE类型是一个结构体，定义在stdio.h中
文件位置指针  // 文件中有一个位置指针，用于指向当前文件的读写位置
标准设备文件是由操作系统控制的，由系统自动打开或关闭，c语言提供了3个标准设备文件的文件指针，stdin、stdout、stderr，定义在stdio.h中

文件打开
FILE *fopen(const char *path, const char *mode);  // 文件不存在时，返回NULL

文件关闭
int fclose(FILE *fp);  // 关闭成功返回NULL，关闭失败返回非NULL值

文件顺序读写
字符读写函数  // 适用于读写较小的文件
int fgetc(FILE *fp);  // 从文件中读取一个字符，正常时返回读取字符的ascii码值，异常时返回EOF（-1）
int fputc(int ch, FILE *fp);  // 写一个字符到文件中，正常时返回读取字符的ascii码值，异常时返回EOF（-1）
字符串读写函数  // 适用于读写较小的文件
char *fgets(char *str, n, FILE *fp);  // 从文件中读取n-1个字符，存储到str所指向的内存中，最后加上结束'\0'，正常时返回字符串str的内存首地址，异常时返回NULL
int fputs(char *str, FILE *fp);  // 将字符串str写入到文件中，正常时返回写入文件的字符个数，即字符串长度，异常时返回NULL
格式化读写函数  // 适用于读写较小的文件
int fscanf(FILE *fp, char *format, char* arg_list);  // 成功时，返回成功读入参数的个数，失败时返回EOF（-1）
int fprintf(FILE *fp, char *format, char* arg_list);  // 成功时，返回写入文件的字符个数，失败时返回一个负值
数据块读写函数 
int fread(void *buffer, unsigned size, unsigned count, FILE *fp);  // 按二进制形式，将size*count个字节读到buffer中，成功时，返回数据块的数量，出错时，返回0
int fwrite(void *buffer, unsigned size, unsigned count, FILE *fp);  // 按二进制形式，将size*count个字节写入，从buffer中读出然后写入到文件中，成功时，返回数据块的数量，出错时，返回0

文件随机读写  // 移动文件位置指针后，可以用任意一种读写函数进行读写
符号常量
SEEK_SET 0  // 文件首
SEEK_CUR 1  // 当前位置
SEEK_END 2  // 文件末尾 
文件定位  // 按要求移动文件位置指针
void rewind(FILE *fp);  // 将文件位置指针宠重新指向文件的首部
int fseek(FILE *fp, long offset, int base);  // 将文件位置指针移到基于base的相对位置offset（以字节为单位）处，正常时返回当前文件位置指针的位置，异常时返回-1，一般用于二进制文件，在文本文件中由于要进行转换，往往计算的位置会出现错误
long ftell(FILE *fp);  // 获取文件位置指针的当前读写位置，正常时返回位移量（以字节为单位），异常时返回-1

文件检测函数
检测文件是否结束
int feof(FILE *fp);  // 如果文件结束返回1，否则返回0
检测读写文件时是否出错
int ferror(FILE *fp);  // 如果读写时没有出现错误，返回0，否则返回非0
重置文件结束标志和文件出错标志
void clearerr(FILE *fp);  // 将文件结束标志和出错标志重置为0

其它文件操作函数
create  // 创建文件，io.h
remove  // 删除文件，stdio.h
searchpath  // 查找文件，dir.h